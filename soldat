defrom flask import Flask, request, jsonify
from pydantic import BaseModel, Field
import csv
from io import TextIOWrapper

# =========================
#       MODELS
# =========================

class Soldier(BaseModel):
    personal_id: str = Field(..., regex=r"^8\d+$")
    first_name: str
    last_name: str
    gender: str
    city: str
    distance_km: int
    status: str = "waiting"      # assigned / waiting
    building: str | None = None
    room_number: int | None = None


# =========================
#       HOUSING SYSTEM
# =========================

class Room:
    def __init__(self, number: int, capacity: int = 8):
        self.number = number
        self.capacity = capacity
        self.soldiers: list[Soldier] = []

    def has_space(self):
        return len(self.soldiers) < self.capacity

    def add_soldier(self, soldier: Soldier):
        if self.has_space():
            self.soldiers.append(soldier)
            return True
        return False


class Building:
    def __init__(self, name: str, rooms_count: int = 10):
        self.name = name
        self.rooms = [Room(i + 1) for i in range(rooms_count)]

    def try_assign(self, soldier: Soldier):
        for room in self.rooms:
            if room.has_space():
                room.add_soldier(soldier)
                soldier.status = "assigned"
                soldier.building = self.name
                soldier.room_number = room.number
                return True
        return False


class BaseHousing:
    def __init__(self):
        self.buildings = [
            Building("A"),
            Building("B")
        ]
        self.waiting_list: list[Soldier] = []

    def assign_soldier(self, soldier: Soldier):
        for b in self.buildings:
            if b.try_assign(soldier):
                return True

        self.waiting_list.append(soldier)
        return False


# =========================
#       API SERVER
# =========================

app = Flask(__name__)
base = BaseHousing()


@app.post("/assignWithCsv")
def assign_with_csv():
    file = request.files.get("file")

    if not file:
        return {"error": "CSV file missing"}, 400

    csv_file = TextIOWrapper(file, encoding="utf-8")
    reader = csv.DictReader(csv_file)

    soldiers: list[Soldier] = []

    # Create soldier objects
    for row in reader:
        soldier = Soldier(
            personal_id=row["personal_id"],
            first_name=row["first_name"],
            last_name=row["last_name"],
            gender=row["gender"],
            city=row["city"],
            distance_km=int(row["distance_km"])
        )
        soldiers.append(soldier)

    # Sorting by distance (descending)
    soldiers.sort(key=lambda s: s.distance_km, reverse=True)

    # Assign soldiers
    for s in soldiers:
        base.assign_soldier(s)

    # Build response
    response = {
        "assigned": sum(1 for s in soldiers if s.status == "assigned"),
        "waiting": sum(1 for s in soldiers if s.status == "waiting"),
        "details": [
            {
                "personal_id": s.personal_id,
                "status": s.status,
                "building": s.building,
                "room": s.room_number
            }
            for s in soldiers
        ]
    }

    return jsonify(response)


# =========================
#       RUN SERVER
# =========================

if __name__ == "__main__":
    app.run(debug=True)


from fastapi import FastAPI, UploadFile, File, HTTPException
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field
import csv
from io import StringIO

# ==========================================
#               MODELS
# ==========================================

class Soldier(BaseModel):
    personal_id: str = Field(..., regex=r"^8\d+$")
    first_name: str
    last_name: str
    gender: str
    city: str
    distance_km: int
    status: str = "waiting"      # assigned / waiting
    building: str | None = None
    room_number: int | None = None


# ==========================================
#         HOUSING SYSTEM (OOP)
# ==========================================

class Room:
    def __init__(self, number: int, capacity: int = 8):
        self.number = number
        self.capacity = capacity
        self.soldiers: list[Soldier] = []

    def has_space(self):
        return len(self.soldiers) < self.capacity

    def add_soldier(self, soldier: Soldier):
        if self.has_space():
            self.soldiers.append(soldier)
            return True
        return False


class Building:
    def __init__(self, name: str, rooms_count: int = 10):
        self.name = name
        self.rooms = [Room(i + 1) for i in range(rooms_count)]

    def try_assign(self, soldier: Soldier):
        for room in self.rooms:
            if room.has_space():
                room.add_soldier(soldier)
                soldier.status = "assigned"
                soldier.building = self.name
                soldier.room_number = room.number
                return True
        return False


class BaseHousing:
    def __init__(self):
        self.buildings = [
            Building("A"),
            Building("B")
        ]
        self.waiting_list: list[Soldier] = []

    def assign_soldier(self, soldier: Soldier):
        for b in self.buildings:
            if b.try_assign(soldier):
                return True
        self.waiting_list.append(soldier)
        return False


# ==========================================
#               FASTAPI APP
# ==========================================

app = FastAPI()
base = BaseHousing()


@app.post("/assignWithCsv")
async def assign_with_csv(file: UploadFile = File(...)):
    if file.content_type not in ["text/csv", "application/vnd.ms-excel"]:
        raise HTTPException(status_code=400, detail="File must be a CSV")

    content = await file.read()
    decoded = content.decode("utf-8")
    csv_reader = csv.DictReader(StringIO(decoded))

    soldiers: list[Soldier] = []

    # Create soldiers
    for row in csv_reader:
        soldier = Soldier(
            personal_id=row["personal_id"],
            first_name=row["first_name"],
            last_name=row["last_name"],
            gender=row["gender"],
            city=row["city"],
            distance_km=int(row["distance_km"])
        )
        soldiers.append(soldier)

    # Sort by distance (descending)
    soldiers.sort(key=lambda s: s.distance_km, reverse=True)

    # Assign soldiers
    for s in soldiers:
        base.assign_soldier(s)

    response = {
        "assigned": sum(1 for s in soldiers if s.status == "assigned"),
        "waiting": sum(1 for s in soldiers if s.status == "waiting"),
        "details": [
            {
                "personal_id": s.personal_id,
                "status": s.status,
                "building": s.building,
                "room": s.room_number
            }
            for s in soldiers
        ]
    }

    return JSONResponse(content=response)


# ==========================================
#               RUN
# ==========================================

# Lancer le serveur :
# uvicorn main:app --reload


from fastapi import FastAPI, UploadFile, File, HTTPException
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field
import csv
from io import StringIO

app = FastAPI()


# ============================
#          MODELES
# ============================

class Soldier(BaseModel):
    personal_id: str = Field(..., regex="^8[0-9]+$")
    first_name: str
    last_name: str
    gender: str
    city: str
    distance_km: int
    status: str = "waiting"
    building: str | None = None
    room: int | None = None


# ============================
#   STRUCTURE DES LOGEMENTS
# ============================

class Room:
    def __init__(self, num):
        self.num = num
        self.capacity = 8
        self.soldiers = []

    def has_place(self):
        return len(self.soldiers) < self.capacity

    def add(self, soldier):
        if self.has_place():
            self.soldiers.append(soldier)
            return True
        return False


class Building:
    def __init__(self, name):
        self.name = name
        self.rooms = [Room(i + 1) for i in range(10)]

    def assign(self, soldier):
        for r in self.rooms:
            if r.has_place():
                r.add(soldier)
                soldier.status = "assigned"
                soldier.building = self.name
                soldier.room = r.num
                return True
        return False


class HousingBase:
    def __init__(self):
        self.buildings = [Building("A"), Building("B")]
        self.waiting = []

    def assign_soldier(self, soldier):
        for b in self.buildings:
            if b.assign(soldier):
                return

        self.waiting.append(soldier)


base = HousingBase()


# ============================
#            API
# ============================

@app.post("/assignWithCsv")
async def assign_with_csv(file: UploadFile = File(...)):
    if file.content_type not in ["text/csv", "application/vnd.ms-excel"]:
        raise HTTPException(400, "Le fichier doit Ãªtre un CSV")

    data = await file.read()
    text = data.decode("utf-8")
    reader = csv.DictReader(StringIO(text))

    soldiers = []

    for row in reader:
        s = Soldier(
            personal_id=row["personal_id"],
            first_name=row["first_name"],
            last_name=row["last_name"],
            gender=row["gender"],
            city=row["city"],
            distance_km=int(row["distance_km"])
        )
        soldiers.append(s)

    soldiers.sort(key=lambda x: x.distance_km, reverse=True)

    for s in soldiers:
        base.assign_soldier(s)

    res = {
        "nb_assigned": len([s for s in soldiers if s.status == "assigned"]),
        "nb_waiting": len([s for s in soldiers if s.status == "waiting"]),
        "soldiers": [
            {
                "id": s.personal_id,
                "status": s.status,
                "building": s.building,
                "room": s.room
            }
            for s in soldiers
        ]
    }

    return JSONResponse(res)


# Pour lancer :
# uvicorn main:app --reload